{
  "rfc_id": "RFC-0007",
  "title": "Secret Set Encryption & Versioning",
  "status": "draft",
  "created": "2025-12-05",
  "authors": ["mycelium-core"],
  "phase": "crypto",
  "depends_on": ["RFC-0006", "RFC-0005"],
  "summary": "Defines how secret sets are encrypted using PDKs, the plaintext format, versioning model, content hashing, hash chaining, and integrity verification.",

  "motivation": {
    "problem": "Secrets (environment variables) must be stored encrypted. We need a format that supports versioning, integrity verification, and efficient diff operations.",
    "solution": "Secrets are stored as key-value pairs in a defined plaintext format, encrypted with the current PDK, and versioned with BLAKE3 hash chaining for integrity."
  },

  "design": {
    "plaintext_format": {
      "description": "The format of secret data before encryption",
      "format": "JSON object",
      "schema": {
        "type": "object",
        "properties": {
          "entries": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "key": { "type": "string", "description": "Environment variable name" },
                "value": { "type": "string", "description": "Secret value" },
                "metadata": {
                  "type": "object",
                  "properties": {
                    "description": { "type": "string" },
                    "created_at": { "type": "string", "format": "date-time" },
                    "updated_at": { "type": "string", "format": "date-time" },
                    "tags": { "type": "array", "items": { "type": "string" } }
                  }
                }
              },
              "required": ["key", "value"]
            }
          }
        }
      },
      "example": {
        "entries": [
          { "key": "DATABASE_URL", "value": "postgres://...", "metadata": { "description": "Primary database" } },
          { "key": "API_KEY", "value": "sk_live_...", "metadata": { "tags": ["stripe", "production"] } }
        ]
      },
      "ordering": "Entries MUST be sorted by key for deterministic serialization"
    },

    "encryption_process": {
      "description": "How plaintext is encrypted to produce ciphertext",
      "steps": [
        {
          "step": 1,
          "action": "Serialize entries to canonical JSON (sorted keys, no whitespace)"
        },
        {
          "step": 2,
          "action": "Compute content_hash = BLAKE3(plaintext_json)"
        },
        {
          "step": 3,
          "action": "Compute chain_hash = BLAKE3(previous_version_chain_hash || content_hash) or content_hash if first version"
        },
        {
          "step": 4,
          "action": "Get current PDK for project"
        },
        {
          "step": 5,
          "action": "Generate random 12-byte nonce"
        },
        {
          "step": 6,
          "action": "Compute AAD = project_id || set_id || version_number || pdk_version (concatenated UUIDs and u64s)"
        },
        {
          "step": 7,
          "action": "ciphertext = ChaCha20-Poly1305(PDK, nonce, plaintext_json, AAD)"
        },
        {
          "step": 8,
          "action": "Output: nonce || ciphertext || tag"
        }
      ]
    },

    "decryption_process": {
      "description": "How ciphertext is decrypted",
      "steps": [
        {
          "step": 1,
          "action": "Read version metadata to get pdk_version"
        },
        {
          "step": 2,
          "action": "Unwrap PDK for that version (see RFC-0006)"
        },
        {
          "step": 3,
          "action": "Parse nonce from first 12 bytes of ciphertext blob"
        },
        {
          "step": 4,
          "action": "Compute AAD = project_id || set_id || version_number || pdk_version"
        },
        {
          "step": 5,
          "action": "plaintext = ChaCha20-Poly1305_decrypt(PDK, nonce, ciphertext, AAD)"
        },
        {
          "step": 6,
          "action": "Verify content_hash matches BLAKE3(plaintext)"
        },
        {
          "step": 7,
          "action": "Verify hash chain if previous version exists"
        },
        {
          "step": 8,
          "action": "Parse JSON, return entries"
        }
      ]
    },

    "versioning": {
      "description": "How versions are numbered and stored",
      "model": {
        "version_number": "u64, starts at 1, monotonically increasing",
        "immutable": "Once written, a version is never modified",
        "append_only": "New versions are appended, old versions are retained"
      },
      "storage": {
        "ciphertext": ".mycelium/projects/<pid>/sets/<sid>/v<N>.enc",
        "metadata": ".mycelium/projects/<pid>/sets/<sid>/v<N>.meta.json"
      },
      "metadata_schema": {
        "schema_version": 1,
        "type": "secret_set_version_meta",
        "data": {
          "set_id": "UUID",
          "version": "u64",
          "pdk_version": "u64",
          "created_at": "RFC3339 timestamp",
          "created_by": "DeviceId",
          "message": "optional string",
          "content_hash": "base64 BLAKE3 hash",
          "chain_hash": "base64 BLAKE3 hash",
          "previous_chain_hash": "base64 BLAKE3 hash or null"
        },
        "signature": "base64 Ed25519 signature",
        "signed_by": "DeviceId"
      }
    },

    "hash_chain": {
      "description": "Integrity chain linking versions",
      "purpose": [
        "Detect tampering with historical versions",
        "Prove version ordering",
        "Enable integrity verification without decryption"
      ],
      "computation": {
        "first_version": "chain_hash = content_hash",
        "subsequent": "chain_hash = BLAKE3(previous_chain_hash || content_hash)"
      },
      "verification": {
        "steps": [
          "For each version from 1 to N:",
          "  1. Read metadata, extract content_hash and previous_chain_hash",
          "  2. Compute expected_chain_hash",
          "  3. Compare with stored chain_hash",
          "  4. If mismatch, chain is broken at this version"
        ]
      }
    },

    "signing": {
      "description": "Every version is signed by the creating device",
      "what_is_signed": "canonical JSON of metadata.data (without signature field)",
      "verification": "Reader verifies signature using device's signing pubkey from registry"
    },

    "operations": {
      "create_version": {
        "signature": "fn create_version(set_id: &SecretSetId, entries: &[SecretEntry], message: Option<&str>, device: &DeviceContext) -> Result<SecretSetVersion>",
        "behavior": "Encrypt entries, compute hashes, sign metadata, return version"
      },
      "read_version": {
        "signature": "fn read_version(set_id: &SecretSetId, version: VersionNumber, device: &DeviceContext) -> Result<Vec<SecretEntry>>",
        "behavior": "Decrypt and verify version, return plaintext entries"
      },
      "read_latest": {
        "signature": "fn read_latest(set_id: &SecretSetId, device: &DeviceContext) -> Result<(VersionNumber, Vec<SecretEntry>)>",
        "behavior": "Read current_version from set metadata, then read that version"
      },
      "list_versions": {
        "signature": "fn list_versions(set_id: &SecretSetId) -> Result<Vec<VersionSummary>>",
        "behavior": "Return list of versions with metadata (no decryption)"
      },
      "verify_chain": {
        "signature": "fn verify_chain(set_id: &SecretSetId) -> Result<ChainVerificationResult>",
        "behavior": "Verify hash chain integrity for all versions"
      },
      "diff_versions": {
        "signature": "fn diff_versions(set_id: &SecretSetId, v1: VersionNumber, v2: VersionNumber, device: &DeviceContext) -> Result<SecretDiff>",
        "behavior": "Decrypt both versions, compute key-level diff"
      }
    },

    "export_formats": {
      "description": "How decrypted secrets can be exported",
      "formats": [
        {
          "name": "dotenv",
          "extension": ".env",
          "format": "KEY=value\n",
          "escaping": "Quote values with spaces or special chars"
        },
        {
          "name": "json",
          "extension": ".json",
          "format": "{ \"KEY\": \"value\" }"
        },
        {
          "name": "shell",
          "extension": ".sh",
          "format": "export KEY='value'\n"
        },
        {
          "name": "yaml",
          "extension": ".yaml",
          "format": "KEY: value"
        }
      ]
    },

    "import_formats": {
      "description": "How secrets can be imported",
      "formats": ["dotenv", "json"],
      "parsing": {
        "dotenv": "Parse KEY=value lines, handle quotes, skip comments (#)",
        "json": "Parse as { \"KEY\": \"value\" } object"
      }
    }
  },

  "size_limits": {
    "max_entries": 10000,
    "max_key_length": 256,
    "max_value_length": 1048576,
    "max_total_plaintext": 10485760,
    "rationale": "Prevent accidental storage of large files as secrets"
  },

  "error_types": {
    "SecretSetError": {
      "variants": [
        { "name": "AccessDenied", "description": "No wrapped PDK for device" },
        { "name": "DecryptionFailed", "description": "PDK unwrap or content decrypt failed" },
        { "name": "HashMismatch", "description": "Content hash doesn't match" },
        { "name": "ChainBroken", "description": "Hash chain verification failed" },
        { "name": "SignatureInvalid", "description": "Metadata signature verification failed" },
        { "name": "VersionNotFound", "description": "Requested version doesn't exist" },
        { "name": "SizeLimitExceeded", "description": "Plaintext exceeds max size" }
      ]
    }
  },

  "acceptance_criteria": [
    "Create version then read version recovers identical entries",
    "Tampering with ciphertext causes DecryptionFailed",
    "Tampering with metadata causes SignatureInvalid",
    "Hash chain verifies for valid sequence of versions",
    "Tampering with historical version breaks chain",
    "Export to dotenv produces valid .env file",
    "Import from dotenv parses correctly",
    "Size limits are enforced",
    "Diff shows added/removed/changed keys"
  ],

  "open_questions": [
    "Should we support binary secret values (base64 encoded)?",
    "Should we support structured/nested secret values?"
  ],
  "resolved_questions": [],
  "changelog": [
    { "date": "2025-12-05", "change": "Initial draft" }
  ]
}
